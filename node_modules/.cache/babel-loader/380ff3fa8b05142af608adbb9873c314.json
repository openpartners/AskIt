{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _get() { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n/*!\n  * Bootstrap dropdown.js v5.1.3 (https://getbootstrap.com/)\n  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)\n  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n  */\n(function (global, factory) {\n  (typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('@popperjs/core'), require('./dom/event-handler.js'), require('./dom/manipulator.js'), require('./dom/selector-engine.js'), require('./base-component.js')) : typeof define === 'function' && define.amd ? define(['@popperjs/core', './dom/event-handler', './dom/manipulator', './dom/selector-engine', './base-component'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Dropdown = factory(global.Popper, global.EventHandler, global.Manipulator, global.SelectorEngine, global.Base));\n})(this, function (Popper, EventHandler, Manipulator, SelectorEngine, BaseComponent) {\n  'use strict';\n\n  var _interopDefaultLegacy = function _interopDefaultLegacy(e) {\n    return e && _typeof(e) === 'object' && 'default' in e ? e : {\n      default: e\n    };\n  };\n\n  function _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n\n    if (e) {\n      var _loop = function _loop(k) {\n        if (k !== 'default') {\n          var d = Object.getOwnPropertyDescriptor(e, k);\n          Object.defineProperty(n, k, d.get ? d : {\n            enumerable: true,\n            get: function get() {\n              return e[k];\n            }\n          });\n        }\n      };\n\n      for (var k in e) {\n        _loop(k);\n      }\n    }\n\n    n.default = e;\n    return Object.freeze(n);\n  }\n\n  var Popper__namespace = /*#__PURE__*/_interopNamespace(Popper);\n\n  var EventHandler__default = /*#__PURE__*/_interopDefaultLegacy(EventHandler);\n\n  var Manipulator__default = /*#__PURE__*/_interopDefaultLegacy(Manipulator);\n\n  var SelectorEngine__default = /*#__PURE__*/_interopDefaultLegacy(SelectorEngine);\n\n  var BaseComponent__default = /*#__PURE__*/_interopDefaultLegacy(BaseComponent);\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.1.3): util/index.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n\n\n  var toType = function toType(obj) {\n    if (obj === null || obj === undefined) {\n      return \"\".concat(obj);\n    }\n\n    return {}.toString.call(obj).match(/\\s([a-z]+)/i)[1].toLowerCase();\n  };\n\n  var getSelector = function getSelector(element) {\n    var selector = element.getAttribute('data-bs-target');\n\n    if (!selector || selector === '#') {\n      var hrefAttr = element.getAttribute('href'); // The only valid content that could double as a selector are IDs or classes,\n      // so everything starting with `#` or `.`. If a \"real\" URL is used as the selector,\n      // `document.querySelector` will rightfully complain it is invalid.\n      // See https://github.com/twbs/bootstrap/issues/32273\n\n      if (!hrefAttr || !hrefAttr.includes('#') && !hrefAttr.startsWith('.')) {\n        return null;\n      } // Just in case some CMS puts out a full URL with the anchor appended\n\n\n      if (hrefAttr.includes('#') && !hrefAttr.startsWith('#')) {\n        hrefAttr = \"#\".concat(hrefAttr.split('#')[1]);\n      }\n\n      selector = hrefAttr && hrefAttr !== '#' ? hrefAttr.trim() : null;\n    }\n\n    return selector;\n  };\n\n  var getElementFromSelector = function getElementFromSelector(element) {\n    var selector = getSelector(element);\n    return selector ? document.querySelector(selector) : null;\n  };\n\n  var isElement = function isElement(obj) {\n    if (!obj || _typeof(obj) !== 'object') {\n      return false;\n    }\n\n    if (typeof obj.jquery !== 'undefined') {\n      obj = obj[0];\n    }\n\n    return typeof obj.nodeType !== 'undefined';\n  };\n\n  var getElement = function getElement(obj) {\n    if (isElement(obj)) {\n      // it's a jQuery object or a node element\n      return obj.jquery ? obj[0] : obj;\n    }\n\n    if (typeof obj === 'string' && obj.length > 0) {\n      return document.querySelector(obj);\n    }\n\n    return null;\n  };\n\n  var typeCheckConfig = function typeCheckConfig(componentName, config, configTypes) {\n    Object.keys(configTypes).forEach(function (property) {\n      var expectedTypes = configTypes[property];\n      var value = config[property];\n      var valueType = value && isElement(value) ? 'element' : toType(value);\n\n      if (!new RegExp(expectedTypes).test(valueType)) {\n        throw new TypeError(\"\".concat(componentName.toUpperCase(), \": Option \\\"\").concat(property, \"\\\" provided type \\\"\").concat(valueType, \"\\\" but expected type \\\"\").concat(expectedTypes, \"\\\".\"));\n      }\n    });\n  };\n\n  var isVisible = function isVisible(element) {\n    if (!isElement(element) || element.getClientRects().length === 0) {\n      return false;\n    }\n\n    return getComputedStyle(element).getPropertyValue('visibility') === 'visible';\n  };\n\n  var isDisabled = function isDisabled(element) {\n    if (!element || element.nodeType !== Node.ELEMENT_NODE) {\n      return true;\n    }\n\n    if (element.classList.contains('disabled')) {\n      return true;\n    }\n\n    if (typeof element.disabled !== 'undefined') {\n      return element.disabled;\n    }\n\n    return element.hasAttribute('disabled') && element.getAttribute('disabled') !== 'false';\n  };\n\n  var noop = function noop() {};\n\n  var getjQuery = function getjQuery() {\n    var _window = window,\n        jQuery = _window.jQuery;\n\n    if (jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {\n      return jQuery;\n    }\n\n    return null;\n  };\n\n  var DOMContentLoadedCallbacks = [];\n\n  var onDOMContentLoaded = function onDOMContentLoaded(callback) {\n    if (document.readyState === 'loading') {\n      // add listener on the first call when the document is in loading state\n      if (!DOMContentLoadedCallbacks.length) {\n        document.addEventListener('DOMContentLoaded', function () {\n          DOMContentLoadedCallbacks.forEach(function (callback) {\n            return callback();\n          });\n        });\n      }\n\n      DOMContentLoadedCallbacks.push(callback);\n    } else {\n      callback();\n    }\n  };\n\n  var isRTL = function isRTL() {\n    return document.documentElement.dir === 'rtl';\n  };\n\n  var defineJQueryPlugin = function defineJQueryPlugin(plugin) {\n    onDOMContentLoaded(function () {\n      var $ = getjQuery();\n      /* istanbul ignore if */\n\n      if ($) {\n        var name = plugin.NAME;\n        var JQUERY_NO_CONFLICT = $.fn[name];\n        $.fn[name] = plugin.jQueryInterface;\n        $.fn[name].Constructor = plugin;\n\n        $.fn[name].noConflict = function () {\n          $.fn[name] = JQUERY_NO_CONFLICT;\n          return plugin.jQueryInterface;\n        };\n      }\n    });\n  };\n  /**\n   * Return the previous/next element of a list.\n   *\n   * @param {array} list    The list of elements\n   * @param activeElement   The active element\n   * @param shouldGetNext   Choose to get next or previous element\n   * @param isCycleAllowed\n   * @return {Element|elem} The proper element\n   */\n\n\n  var getNextActiveElement = function getNextActiveElement(list, activeElement, shouldGetNext, isCycleAllowed) {\n    var index = list.indexOf(activeElement); // if the element does not exist in the list return an element depending on the direction and if cycle is allowed\n\n    if (index === -1) {\n      return list[!shouldGetNext && isCycleAllowed ? list.length - 1 : 0];\n    }\n\n    var listLength = list.length;\n    index += shouldGetNext ? 1 : -1;\n\n    if (isCycleAllowed) {\n      index = (index + listLength) % listLength;\n    }\n\n    return list[Math.max(0, Math.min(index, listLength - 1))];\n  };\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.1.3): dropdown.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n\n  var NAME = 'dropdown';\n  var DATA_KEY = 'bs.dropdown';\n  var EVENT_KEY = \".\".concat(DATA_KEY);\n  var DATA_API_KEY = '.data-api';\n  var ESCAPE_KEY = 'Escape';\n  var SPACE_KEY = 'Space';\n  var TAB_KEY = 'Tab';\n  var ARROW_UP_KEY = 'ArrowUp';\n  var ARROW_DOWN_KEY = 'ArrowDown';\n  var RIGHT_MOUSE_BUTTON = 2; // MouseEvent.button value for the secondary button, usually the right button\n\n  var REGEXP_KEYDOWN = new RegExp(\"\".concat(ARROW_UP_KEY, \"|\").concat(ARROW_DOWN_KEY, \"|\").concat(ESCAPE_KEY));\n  var EVENT_HIDE = \"hide\".concat(EVENT_KEY);\n  var EVENT_HIDDEN = \"hidden\".concat(EVENT_KEY);\n  var EVENT_SHOW = \"show\".concat(EVENT_KEY);\n  var EVENT_SHOWN = \"shown\".concat(EVENT_KEY);\n  var EVENT_CLICK_DATA_API = \"click\".concat(EVENT_KEY).concat(DATA_API_KEY);\n  var EVENT_KEYDOWN_DATA_API = \"keydown\".concat(EVENT_KEY).concat(DATA_API_KEY);\n  var EVENT_KEYUP_DATA_API = \"keyup\".concat(EVENT_KEY).concat(DATA_API_KEY);\n  var CLASS_NAME_SHOW = 'show';\n  var CLASS_NAME_DROPUP = 'dropup';\n  var CLASS_NAME_DROPEND = 'dropend';\n  var CLASS_NAME_DROPSTART = 'dropstart';\n  var CLASS_NAME_NAVBAR = 'navbar';\n  var SELECTOR_DATA_TOGGLE = '[data-bs-toggle=\"dropdown\"]';\n  var SELECTOR_MENU = '.dropdown-menu';\n  var SELECTOR_NAVBAR_NAV = '.navbar-nav';\n  var SELECTOR_VISIBLE_ITEMS = '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)';\n  var PLACEMENT_TOP = isRTL() ? 'top-end' : 'top-start';\n  var PLACEMENT_TOPEND = isRTL() ? 'top-start' : 'top-end';\n  var PLACEMENT_BOTTOM = isRTL() ? 'bottom-end' : 'bottom-start';\n  var PLACEMENT_BOTTOMEND = isRTL() ? 'bottom-start' : 'bottom-end';\n  var PLACEMENT_RIGHT = isRTL() ? 'left-start' : 'right-start';\n  var PLACEMENT_LEFT = isRTL() ? 'right-start' : 'left-start';\n  var Default = {\n    offset: [0, 2],\n    boundary: 'clippingParents',\n    reference: 'toggle',\n    display: 'dynamic',\n    popperConfig: null,\n    autoClose: true\n  };\n  var DefaultType = {\n    offset: '(array|string|function)',\n    boundary: '(string|element)',\n    reference: '(string|element|object)',\n    display: 'string',\n    popperConfig: '(null|object|function)',\n    autoClose: '(boolean|string)'\n  };\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n\n  var Dropdown = /*#__PURE__*/function (_BaseComponent__defau) {\n    _inherits(Dropdown, _BaseComponent__defau);\n\n    var _super = _createSuper(Dropdown);\n\n    function Dropdown(element, config) {\n      var _this;\n\n      _classCallCheck(this, Dropdown);\n\n      _this = _super.call(this, element);\n      _this._popper = null;\n      _this._config = _this._getConfig(config);\n      _this._menu = _this._getMenuElement();\n      _this._inNavbar = _this._detectNavbar();\n      return _this;\n    } // Getters\n\n\n    _createClass(Dropdown, [{\n      key: \"toggle\",\n      value: // Public\n      function toggle() {\n        return this._isShown() ? this.hide() : this.show();\n      }\n    }, {\n      key: \"show\",\n      value: function show() {\n        if (isDisabled(this._element) || this._isShown(this._menu)) {\n          return;\n        }\n\n        var relatedTarget = {\n          relatedTarget: this._element\n        };\n        var showEvent = EventHandler__default.default.trigger(this._element, EVENT_SHOW, relatedTarget);\n\n        if (showEvent.defaultPrevented) {\n          return;\n        }\n\n        var parent = Dropdown.getParentFromElement(this._element); // Totally disable Popper for Dropdowns in Navbar\n\n        if (this._inNavbar) {\n          Manipulator__default.default.setDataAttribute(this._menu, 'popper', 'none');\n        } else {\n          this._createPopper(parent);\n        } // If this is a touch-enabled device we add extra\n        // empty mouseover listeners to the body's immediate children;\n        // only needed because of broken event delegation on iOS\n        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n\n\n        if ('ontouchstart' in document.documentElement && !parent.closest(SELECTOR_NAVBAR_NAV)) {\n          var _ref;\n\n          (_ref = []).concat.apply(_ref, _toConsumableArray(document.body.children)).forEach(function (elem) {\n            return EventHandler__default.default.on(elem, 'mouseover', noop);\n          });\n        }\n\n        this._element.focus();\n\n        this._element.setAttribute('aria-expanded', true);\n\n        this._menu.classList.add(CLASS_NAME_SHOW);\n\n        this._element.classList.add(CLASS_NAME_SHOW);\n\n        EventHandler__default.default.trigger(this._element, EVENT_SHOWN, relatedTarget);\n      }\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        if (isDisabled(this._element) || !this._isShown(this._menu)) {\n          return;\n        }\n\n        var relatedTarget = {\n          relatedTarget: this._element\n        };\n\n        this._completeHide(relatedTarget);\n      }\n    }, {\n      key: \"dispose\",\n      value: function dispose() {\n        if (this._popper) {\n          this._popper.destroy();\n        }\n\n        _get(_getPrototypeOf(Dropdown.prototype), \"dispose\", this).call(this);\n      }\n    }, {\n      key: \"update\",\n      value: function update() {\n        this._inNavbar = this._detectNavbar();\n\n        if (this._popper) {\n          this._popper.update();\n        }\n      } // Private\n\n    }, {\n      key: \"_completeHide\",\n      value: function _completeHide(relatedTarget) {\n        var hideEvent = EventHandler__default.default.trigger(this._element, EVENT_HIDE, relatedTarget);\n\n        if (hideEvent.defaultPrevented) {\n          return;\n        } // If this is a touch-enabled device we remove the extra\n        // empty mouseover listeners we added for iOS support\n\n\n        if ('ontouchstart' in document.documentElement) {\n          var _ref2;\n\n          (_ref2 = []).concat.apply(_ref2, _toConsumableArray(document.body.children)).forEach(function (elem) {\n            return EventHandler__default.default.off(elem, 'mouseover', noop);\n          });\n        }\n\n        if (this._popper) {\n          this._popper.destroy();\n        }\n\n        this._menu.classList.remove(CLASS_NAME_SHOW);\n\n        this._element.classList.remove(CLASS_NAME_SHOW);\n\n        this._element.setAttribute('aria-expanded', 'false');\n\n        Manipulator__default.default.removeDataAttribute(this._menu, 'popper');\n        EventHandler__default.default.trigger(this._element, EVENT_HIDDEN, relatedTarget);\n      }\n    }, {\n      key: \"_getConfig\",\n      value: function _getConfig(config) {\n        config = _objectSpread(_objectSpread(_objectSpread({}, this.constructor.Default), Manipulator__default.default.getDataAttributes(this._element)), config);\n        typeCheckConfig(NAME, config, this.constructor.DefaultType);\n\n        if (_typeof(config.reference) === 'object' && !isElement(config.reference) && typeof config.reference.getBoundingClientRect !== 'function') {\n          // Popper virtual elements require a getBoundingClientRect method\n          throw new TypeError(\"\".concat(NAME.toUpperCase(), \": Option \\\"reference\\\" provided type \\\"object\\\" without a required \\\"getBoundingClientRect\\\" method.\"));\n        }\n\n        return config;\n      }\n    }, {\n      key: \"_createPopper\",\n      value: function _createPopper(parent) {\n        if (typeof Popper__namespace === 'undefined') {\n          throw new TypeError('Bootstrap\\'s dropdowns require Popper (https://popper.js.org)');\n        }\n\n        var referenceElement = this._element;\n\n        if (this._config.reference === 'parent') {\n          referenceElement = parent;\n        } else if (isElement(this._config.reference)) {\n          referenceElement = getElement(this._config.reference);\n        } else if (_typeof(this._config.reference) === 'object') {\n          referenceElement = this._config.reference;\n        }\n\n        var popperConfig = this._getPopperConfig();\n\n        var isDisplayStatic = popperConfig.modifiers.find(function (modifier) {\n          return modifier.name === 'applyStyles' && modifier.enabled === false;\n        });\n        this._popper = Popper__namespace.createPopper(referenceElement, this._menu, popperConfig);\n\n        if (isDisplayStatic) {\n          Manipulator__default.default.setDataAttribute(this._menu, 'popper', 'static');\n        }\n      }\n    }, {\n      key: \"_isShown\",\n      value: function _isShown() {\n        var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._element;\n        return element.classList.contains(CLASS_NAME_SHOW);\n      }\n    }, {\n      key: \"_getMenuElement\",\n      value: function _getMenuElement() {\n        return SelectorEngine__default.default.next(this._element, SELECTOR_MENU)[0];\n      }\n    }, {\n      key: \"_getPlacement\",\n      value: function _getPlacement() {\n        var parentDropdown = this._element.parentNode;\n\n        if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {\n          return PLACEMENT_RIGHT;\n        }\n\n        if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {\n          return PLACEMENT_LEFT;\n        } // We need to trim the value because custom properties can also include spaces\n\n\n        var isEnd = getComputedStyle(this._menu).getPropertyValue('--bs-position').trim() === 'end';\n\n        if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {\n          return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;\n        }\n\n        return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;\n      }\n    }, {\n      key: \"_detectNavbar\",\n      value: function _detectNavbar() {\n        return this._element.closest(\".\".concat(CLASS_NAME_NAVBAR)) !== null;\n      }\n    }, {\n      key: \"_getOffset\",\n      value: function _getOffset() {\n        var _this2 = this;\n\n        var offset = this._config.offset;\n\n        if (typeof offset === 'string') {\n          return offset.split(',').map(function (val) {\n            return Number.parseInt(val, 10);\n          });\n        }\n\n        if (typeof offset === 'function') {\n          return function (popperData) {\n            return offset(popperData, _this2._element);\n          };\n        }\n\n        return offset;\n      }\n    }, {\n      key: \"_getPopperConfig\",\n      value: function _getPopperConfig() {\n        var defaultBsPopperConfig = {\n          placement: this._getPlacement(),\n          modifiers: [{\n            name: 'preventOverflow',\n            options: {\n              boundary: this._config.boundary\n            }\n          }, {\n            name: 'offset',\n            options: {\n              offset: this._getOffset()\n            }\n          }]\n        }; // Disable Popper if we have a static display\n\n        if (this._config.display === 'static') {\n          defaultBsPopperConfig.modifiers = [{\n            name: 'applyStyles',\n            enabled: false\n          }];\n        }\n\n        return _objectSpread(_objectSpread({}, defaultBsPopperConfig), typeof this._config.popperConfig === 'function' ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig);\n      }\n    }, {\n      key: \"_selectMenuItem\",\n      value: function _selectMenuItem(_ref3) {\n        var key = _ref3.key,\n            target = _ref3.target;\n        var items = SelectorEngine__default.default.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter(isVisible);\n\n        if (!items.length) {\n          return;\n        } // if target isn't included in items (e.g. when expanding the dropdown)\n        // allow cycling to get the last item in case key equals ARROW_UP_KEY\n\n\n        getNextActiveElement(items, target, key === ARROW_DOWN_KEY, !items.includes(target)).focus();\n      } // Static\n\n    }], [{\n      key: \"Default\",\n      get: function get() {\n        return Default;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME;\n      }\n    }, {\n      key: \"jQueryInterface\",\n      value: function jQueryInterface(config) {\n        return this.each(function () {\n          var data = Dropdown.getOrCreateInstance(this, config);\n\n          if (typeof config !== 'string') {\n            return;\n          }\n\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\".concat(config, \"\\\"\"));\n          }\n\n          data[config]();\n        });\n      }\n    }, {\n      key: \"clearMenus\",\n      value: function clearMenus(event) {\n        if (event && (event.button === RIGHT_MOUSE_BUTTON || event.type === 'keyup' && event.key !== TAB_KEY)) {\n          return;\n        }\n\n        var toggles = SelectorEngine__default.default.find(SELECTOR_DATA_TOGGLE);\n\n        for (var i = 0, len = toggles.length; i < len; i++) {\n          var context = Dropdown.getInstance(toggles[i]);\n\n          if (!context || context._config.autoClose === false) {\n            continue;\n          }\n\n          if (!context._isShown()) {\n            continue;\n          }\n\n          var relatedTarget = {\n            relatedTarget: context._element\n          };\n\n          if (event) {\n            var composedPath = event.composedPath();\n            var isMenuTarget = composedPath.includes(context._menu);\n\n            if (composedPath.includes(context._element) || context._config.autoClose === 'inside' && !isMenuTarget || context._config.autoClose === 'outside' && isMenuTarget) {\n              continue;\n            } // Tab navigation through the dropdown menu or events from contained inputs shouldn't close the menu\n\n\n            if (context._menu.contains(event.target) && (event.type === 'keyup' && event.key === TAB_KEY || /input|select|option|textarea|form/i.test(event.target.tagName))) {\n              continue;\n            }\n\n            if (event.type === 'click') {\n              relatedTarget.clickEvent = event;\n            }\n          }\n\n          context._completeHide(relatedTarget);\n        }\n      }\n    }, {\n      key: \"getParentFromElement\",\n      value: function getParentFromElement(element) {\n        return getElementFromSelector(element) || element.parentNode;\n      }\n    }, {\n      key: \"dataApiKeydownHandler\",\n      value: function dataApiKeydownHandler(event) {\n        // If not input/textarea:\n        //  - And not a key in REGEXP_KEYDOWN => not a dropdown command\n        // If input/textarea:\n        //  - If space key => not a dropdown command\n        //  - If key is other than escape\n        //    - If key is not up or down => not a dropdown command\n        //    - If trigger inside the menu => not a dropdown command\n        if (/input|textarea/i.test(event.target.tagName) ? event.key === SPACE_KEY || event.key !== ESCAPE_KEY && (event.key !== ARROW_DOWN_KEY && event.key !== ARROW_UP_KEY || event.target.closest(SELECTOR_MENU)) : !REGEXP_KEYDOWN.test(event.key)) {\n          return;\n        }\n\n        var isActive = this.classList.contains(CLASS_NAME_SHOW);\n\n        if (!isActive && event.key === ESCAPE_KEY) {\n          return;\n        }\n\n        event.preventDefault();\n        event.stopPropagation();\n\n        if (isDisabled(this)) {\n          return;\n        }\n\n        var getToggleButton = this.matches(SELECTOR_DATA_TOGGLE) ? this : SelectorEngine__default.default.prev(this, SELECTOR_DATA_TOGGLE)[0];\n        var instance = Dropdown.getOrCreateInstance(getToggleButton);\n\n        if (event.key === ESCAPE_KEY) {\n          instance.hide();\n          return;\n        }\n\n        if (event.key === ARROW_UP_KEY || event.key === ARROW_DOWN_KEY) {\n          if (!isActive) {\n            instance.show();\n          }\n\n          instance._selectMenuItem(event);\n\n          return;\n        }\n\n        if (!isActive || event.key === SPACE_KEY) {\n          Dropdown.clearMenus();\n        }\n      }\n    }]);\n\n    return Dropdown;\n  }(BaseComponent__default.default);\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n\n\n  EventHandler__default.default.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE, Dropdown.dataApiKeydownHandler);\n  EventHandler__default.default.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);\n  EventHandler__default.default.on(document, EVENT_CLICK_DATA_API, Dropdown.clearMenus);\n  EventHandler__default.default.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);\n  EventHandler__default.default.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {\n    event.preventDefault();\n    Dropdown.getOrCreateInstance(this).toggle();\n  });\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   * add .Dropdown to jQuery only if jQuery is present\n   */\n\n  defineJQueryPlugin(Dropdown);\n  return Dropdown;\n});","map":null,"metadata":{},"sourceType":"module"}